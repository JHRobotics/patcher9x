/******************************************************************************
 * Copyright (c) 2022 Jaroslav Hensl                                          *
 *                                                                            *
 * Permission is hereby granted, free of charge, to any person                *
 * obtaining a copy of this software and associated documentation             *
 * files (the "Software"), to deal in the Software without                    *
 * restriction, including without limitation the rights to use,               *
 * copy, modify, merge, publish, distribute, sublicense, and/or sell          *
 * copies of the Software, and to permit persons to whom the                  *
 * Software is furnished to do so, subject to the following                   *
 * conditions:                                                                *
 *                                                                            *
 * The above copyright notice and this permission notice shall be             *
 * included in all copies or substantial portions of the Software.            *
 *                                                                            *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,            *
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES            *
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND                   *
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT                *
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,               *
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING               *
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR              *
 * OTHER DEALINGS IN THE SOFTWARE.                                            *
 *                                                                            *
*******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <bitstream.h>
#include <bpatcher.h>
#include "fasmdiff.h"

const char *h_header = \
	"/****** Generated by " __FILE__ " ******/\n" \
	"/******    changes may be lost   ******/\n\n" \
	"#ifndef __VMM_PATCH_H__INCLUDED__\n" \
	"#define __VMM_PATCH_H__INCLUDED__\n\n";

const char *h_footer = "#endif /* __VMM_PATCH_H__INCLUDED__ */\n";

static size_t file_size(FILE *fp)
{
	size_t cur, end;
	
	cur = ftell(fp);
	fseek(fp, 0, SEEK_END);
	end = ftell(fp);
	fseek(fp, cur, SEEK_SET);
	
	return end;
}

int main(int argc, char *argv[])
{
	uint8_t *mem1 = NULL, *mem2 = NULL, *mem3 = NULL; /* buffer for fread */
	
	size_t dumped_s, original_s, patched_s, reallocated_s, bin_size, patch_ofset, patch_size;
	
	FILE *dumped      = NULL; /* memory dump or copy from file original windows VMM.VXD */
	FILE *original    = NULL; /* assembled code with original sequence */
	FILE *patched     = NULL; /* assembled new code */
	FILE *reallocated = NULL; /* assembled original code but with rellocated all absolute addreseses */
	
	void *patch_diff_mem = NULL, *realloc_diff_mem = NULL, *orig_diff_mem = NULL, *cmp_mem = NULL;
	
	bitstream_t patch_diff;   /* difference: original<->patched */
	bitstream_t realloc_diff; /* difference: original<->reallocated */
	bitstream_t orig_diff;    /* difference: original<->dumped */
	bitstream_t cmp;          /* compare results */
		
	int result = EXIT_FAILURE;

	if(argc < 4)
	{
		printf("Usage: %s <required size of binaries> <patch offset> <patch size>\n", argv[0]);
		return EXIT_FAILURE;
	}
	else
	{
		bin_size    = strtoul(argv[1], NULL, 0);
		patch_ofset = strtoul(argv[2], NULL, 0);
		patch_size  = strtoul(argv[3], NULL, 0);
	}

	dumped = fopen("vmm/dump.bin", "rb");
	original = fopen("vmm/original.bin", "rb");
	patched = fopen("vmm/patched.bin", "rb");
	reallocated = fopen("vmm/reloc.bin", "rb");
	
	if(original != NULL && patched != NULL && reallocated != NULL)
	{
		dumped_s = 0;
		if(dumped)
		{
			dumped_s = file_size(dumped);
		}
		
		original_s   = file_size(original);
		patched_s    = file_size(patched);
		reallocated_s = file_size(reallocated);
		
		if(dumped != NULL && dumped_s != bin_size)
		{
			printf("dump.bin: invalid size\n");
		}
		else if(original_s != bin_size)
		{
			printf("original.bin: invalid size\n");
		}
		else if(patched_s != bin_size)
		{
			printf("patched.bin: invalid size\n");
		}
		else if(reallocated_s != bin_size)
		{
			printf("realloc.bin: invalid size\n");
		}
		else
		{
			size_t site_bs = bs_calc_size(bin_size);
			uint8_t buf8 = 0;
			
			/* buffers */
			mem1 = malloc(bin_size);
			mem2 = malloc(bin_size);
			mem3 = malloc(bin_size);
			
			/* bitstreams */
			patch_diff_mem   = bs_mem_alloc(&patch_diff, site_bs);
			realloc_diff_mem = bs_mem_alloc(&realloc_diff, site_bs);
			orig_diff_mem    = bs_mem_alloc(&orig_diff, site_bs);
			cmp_mem          = bs_mem_alloc(&cmp, site_bs);
			
			if(mem1 != NULL && mem2 != NULL && mem3 != NULL && 
				patch_diff_mem != NULL && realloc_diff_mem != NULL && orig_diff_mem != NULL &&
				cmp_mem != NULL)
			{
				size_t i, j;
				int test_realoc = 1;
				
				fread(mem1, 1, bin_size, original);
				fread(mem2, 1, bin_size, reallocated);
				diff_sieve(mem1, mem2, bin_size, &realloc_diff);
				
				fread(mem2, 1, bin_size, patched);
				diff_sieve(mem1, mem2, bin_size, &patch_diff);
				
				if(dumped != NULL)
				{
					fread(mem3, 1, bin_size, dumped);
					diff_sieve(mem1, mem3, bin_size, &orig_diff);
				}
				else
				{
					fprintf(stderr, "Warning: dump.bin missing, some tests skipped\n");
					
					bs_mem_free(&orig_diff);
					orig_diff_mem = NULL;
					bs_mem(&orig_diff, (uint8_t*)vmm_fasmdiff, sizeof(vmm_fasmdiff));
				}
				
				/* file header */
				printf("%s", h_header);
				
				bs_reset(&patch_diff);
				bs_reset(&realloc_diff);
				bs_reset(&cmp);
				bs_logic(BS_AND, &patch_diff, &realloc_diff, &cmp, bin_size);
				bs_reset(&cmp);
				test_realoc = bs_is_zero(&cmp, bin_size);
				
				bs_reset(&orig_diff);
				bs_reset(&realloc_diff);
				bs_reset(&cmp);
				bs_logic(BS_OR, &orig_diff, &realloc_diff, &cmp, bin_size);
								
				// orig
				printf("/* original data for search */\nconst uint8_t vmm_orig[] = {");
				for(i = 0; i < patch_size; i++)
				{
					if(i % 16 == 0)
					{
						printf("\n\t");
					}
					printf("0x%02X, ", mem1[patch_ofset+i]);
				}
				printf("\n};\n\n");
				
				// orig_check
				bs_reset(&cmp);
				i = patch_ofset % 8;
				j = 0;
				if(i != 0)
				{
					buf8 = bs_read_bit(&cmp, i);
				}
				printf("/* bitmap of bytes to check */\nconst uint8_t vmm_orig_check[] = {\n\t");
				for(; i < bin_size; i += 8)
				{
				  buf8 = ~bs_read_bit(&cmp, 8);
				  if(i >= patch_ofset && i < patch_ofset+patch_size)
				  {
						if((j++) % 16 == 0)
						{
							printf("\n\t");
						}
						printf("0x%02X, ", buf8);
					}
				}
				printf("\n};\n\n");
				
				// patch
				printf("/* new data to replace */\nconst uint8_t vmm_patch[] = {");
				for(i = 0; i < patch_size; i++)
				{
					if(i % 16 == 0)
					{
						printf("\n\t");
					}
					printf("0x%02X, ", mem2[patch_ofset+i]);
				}
				printf("\n};\n\n");
				
				// patch_modif
				bs_reset(&patch_diff);
				i = patch_ofset % 8;
				j = 0;
			
				if(i != 0)
				{
					buf8 = bs_read_bit(&patch_diff, i);
				}
				printf("/* bitmap of modify bytes */\nconst uint8_t vmm_patch_modif[] = {");
				for(; i < bin_size; i += 8)
				{
				  buf8 = bs_read_bit(&patch_diff, 8);
				  if(i >= patch_ofset && i < patch_ofset+patch_size)
				  {
						if((j++) % 16 == 0)
						{
							printf("\n\t");
						}
						printf("0x%02X, ", buf8);
					}
				}
				printf("\n};\n\n");
				
				/* file end */
				printf("%s", h_footer);
				
				if(test_realoc == 0)
				{
					fprintf(stderr, "Error: Code changes on reallocate symbols!\n");
				}
				else
				{
					result = EXIT_SUCCESS;
				}
				
			}
			else
			{
				printf("Out of memory\n");
			}
		}
	}
	else
	{
		printf("Required files are: original.bin, patched.bin and realloc.bin\n");
	}
	
	
	if(dumped != NULL)      fclose(dumped);
	if(original != NULL)    fclose(original);
	if(patched != NULL)	    fclose(patched);
	if(reallocated != NULL) fclose(reallocated);
	
	if(mem1 != NULL) free(mem1);
	if(mem2 != NULL) free(mem2);
	if(mem3 != NULL) free(mem3);
	
	if(patch_diff_mem)   bs_mem_free(&patch_diff);
	if(realloc_diff_mem) bs_mem_free(&realloc_diff);
	if(orig_diff_mem)    bs_mem_free(&orig_diff);
	if(cmp_mem)          bs_mem_free(&cmp);

	return result;
}
